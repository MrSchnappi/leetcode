# Leetcode 刷题笔记！
# Data Structure
## Array&String(std::vector, std::string)
- 前缀和:限制前缀和所对应的字串长度时,应反向索引,在某一元素可使用时再加入map或其他查询容器中

## Stack(std::stack)
- 常规应用:150逆波兰表达式 71路径简化
- 单调栈:弹出比栈顶小的元素(下标),来获得每个元素的下一个更大元素,739每日温度 剑指59II队列的最大值 503下一个更大元素
- 括号匹配及其变种 394字符串解码
- 括号匹配+算符优先级 227基本计算器
- 删除部分字符串问题:不断清除逆序对中较大元素,可能需要添加更多规则 402移除k位数字 316去除重复字母
## LinkedList
TODO: 148排序链表 147链表插入排序 109有序链表转BST
- 反转 92
- 倒数第N个19 中点143
- 寻找分叉 环
- 插入 删除
- 分隔86 旋转61
## Map(std::map, std::unordered_map)<br>Heap(std::priority_queue)
TODO: 767重构字符串 454四数相加II 659分隔数组为连续子序列
- 容器默认是按key升序排列,否则应传入is_less模板参数用于比较
- map用于缓存和查询 3无重复的最长子串 560和为K的字数组
- top K问题及其变种 215第K大的元素
- priority_queue/partition实现:结果是/否有序
- priority_queue可以为线性访问容器增加堆的功能
- 按value排序:使用priority_queue适配器? 347前K个高频单词
- key的问题:分类时如何为元素建立正确和有效的索引 49字母异位词分组 36有效的数独 973最接近原点的k个点438字母异位词
- **容器的迭代器构造**
## Binary (Search) Tree
### **背诵:四种遍历方法的迭代(有/无路径版本)**
- 基于队列的层次遍历 102层序遍历
- 基于两个stack的层次遍历 103锯齿形遍历
- 遍历过程中的路径维护
- 节点遍历的handler
- 路径深入的handler/条件判断(pruning)
- 路径回退的handler
---
TODO: **平衡二叉树的增删操作** 701插入 450删除 654最大二叉树
- 遍历过程中修改指针操作:注意是否影响遍历代码 114二叉树展开为链表
- BST与中序遍历 538BST转累加树 230BST中第K小的元素
- 平衡二叉树 高度 后序遍历 814二叉树剪枝 ???验证平衡二叉树
- 重建二叉树:以先/后序遍历为基础,在中序遍历中查找 105/106
- **基于stack的重建二叉树?**
- 左侧链
- 更新访问过的节点的值来完成算法 337打家劫舍III
- 二叉搜索树的迭代器 173迭代器
# Algorithm
## Bit Operation
## Double Pointers
- 从容器两侧开始遍历
- 链表的快慢指针常规trick
- 18四数之和:排序+双指针
## Binary Search
- 基于下标中点查询值 标准二分查找/upper bound/lower bound
- 统计满二叉树的节点个数等其他变种 222完全二叉树的节点个数
- 基于值的中点查询下标:378有序矩阵的topK 两个有序序列的中位数
## Sorting
## Dynamic Programming
- 问题判定:最优子结构
- 边界条件/递归基
- 状态转移方程:预设子问题的解已知
- 空间优化:观察dp数组的引用,未被引用的空间可改为滚动数组
## Greedy Alogorithm